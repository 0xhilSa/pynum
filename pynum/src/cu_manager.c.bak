#include <Python.h>
#include <cuda_runtime.h>
#include <stdio.h>
#include <stdlib.h>

#define CUDA_CHECK(call)                                      \
    do {                                                     \
        cudaError_t err = call;                              \
        if (err != cudaSuccess) {                            \
            fprintf(stderr, "CUDA Error: %s\n", cudaGetErrorString(err)); \
            PyErr_SetString(PyExc_RuntimeError, cudaGetErrorString(err)); \
            return NULL;                                     \
        }                                                    \
    } while (0)

// allocate memory on the CUDA device
static PyObject* py_cuda_alloc(PyObject* self, PyObject* args){
    PyObject* py_host_vec;
    if (!PyArg_ParseTuple(args, "O", &py_host_vec)){ return NULL; }

    if (!PyList_Check(py_host_vec)) {
        PyErr_SetString(PyExc_TypeError, "Expected a list of integers");
        return NULL;
    }

    size_t length = PyList_Size(py_host_vec);
    void* device_ptr = NULL;
    size_t size = length * sizeof(int);
    CUDA_CHECK(cudaMalloc(&device_ptr, size));

    return PyLong_FromVoidPtr(device_ptr);
}

// copy memory from host to device
static PyObject* py_memcpy_htod(PyObject* self, PyObject* args){
  PyObject* py_host_vec;
  PyObject* py_device_ptr;

  if(!PyArg_ParseTuple(args, "OO", &py_device_ptr, &py_host_vec)){ return NULL; }

  if(!PyList_Check(py_host_vec)){
    PyErr_SetString(PyExc_TypeError, "Expected a list of integers");
    return NULL;
  }

  int* device_ptr = (int*)PyLong_AsVoidPtr(py_device_ptr);
  size_t length = PyList_Size(py_host_vec);
  int* host_vec = (int*)malloc(length * sizeof(int));

  if(!host_vec){
      PyErr_SetString(PyExc_MemoryError, "Failed to allocate host memory");
      return NULL;
  }

  for(size_t i = 0; i < length; i++){ host_vec[i] = (int)PyLong_AsLong(PyList_GetItem(py_host_vec, i)); }

  size_t size = length * sizeof(int);
  CUDA_CHECK(cudaMemcpy(device_ptr, host_vec, size, cudaMemcpyHostToDevice));
  free(host_vec);

  Py_RETURN_NONE;
}

// copy memory from device to host
static PyObject* py_memcpy_dtoh(PyObject* self, PyObject* args){
  PyObject* py_device_ptr;
  Py_ssize_t length;

  if(!PyArg_ParseTuple(args, "On", &py_device_ptr, &length)){ return NULL; }

  int* device_ptr = (int*)PyLong_AsVoidPtr(py_device_ptr);
  int* host_vec = (int*)malloc(length * sizeof(int));

  if(!host_vec){
    PyErr_SetString(PyExc_MemoryError, "Failed to allocate host memory");
    return NULL;
  }

  size_t size = length * sizeof(int);
  CUDA_CHECK(cudaMemcpy(host_vec, device_ptr, size, cudaMemcpyDeviceToHost));

  PyObject* py_host_vec = PyList_New(length);
  for(Py_ssize_t i = 0; i < length; i++){
    PyList_SetItem(py_host_vec, i, PyLong_FromLong(host_vec[i]));
  }

  free(host_vec);
  return py_host_vec;
}

// Copy memory from host to host
static PyObject* py_memcpy_htoh(PyObject* self, PyObject* args) {
  PyObject* py_src_list;
  Py_ssize_t length;

  if(!PyArg_ParseTuple(args, "On", &py_src_list, &length)) return NULL;

  if(!PyList_Check(py_src_list)){
    PyErr_SetString(PyExc_TypeError, "Expected a list of integers");
    return NULL;
  }

  int* src_array = (int*)malloc(length * sizeof(int));
  if(!src_array){
    PyErr_SetString(PyExc_MemoryError, "Failed to allocate source memory");
    return NULL;
  }

  for(Py_ssize_t i = 0; i < length; i++){
    PyObject* item = PyList_GetItem(py_src_list, i);
    if(!PyLong_Check(item)) {
      free(src_array);
      PyErr_SetString(PyExc_TypeError, "List items must be integers");
      return NULL;
    }
    src_array[i] = (int)PyLong_AsLong(item);
  }

  int* dst_array = (int*)malloc(length * sizeof(int));
  if(!dst_array){
    free(src_array);
    PyErr_SetString(PyExc_MemoryError, "Failed to allocate destination memory");
    return NULL;
  }

  memcpy(dst_array, src_array, length * sizeof(int));
  PyObject* py_dst_list = PyList_New(length);
  if(!py_dst_list){
    free(src_array);
    free(dst_array);
    PyErr_SetString(PyExc_RuntimeError, "Failed to create Python list");
    return NULL;
  }

  for (Py_ssize_t i = 0; i < length; i++) {
    PyObject* py_int = PyLong_FromLong(dst_array[i]);
    if(!py_int){
      Py_DECREF(py_dst_list);
      free(src_array);
      free(dst_array);
      PyErr_SetString(PyExc_RuntimeError, "Failed to create Python integer");
      return NULL;
      }
    PyList_SetItem(py_dst_list, i, py_int);
  }

  free(src_array);
  free(dst_array);

  return py_dst_list;
}

// copy memory from device to device
static PyObject* py_memcpy_dtod(PyObject* self, PyObject* args){
  PyObject* py_src_ptr;
  PyObject* py_dst_ptr;
  Py_ssize_t length;

  if(!PyArg_ParseTuple(args, "OOn", &py_dst_ptr, &py_src_ptr, &length)){ return NULL; }

  int* src_ptr = (int*)PyLong_AsVoidPtr(py_src_ptr);
  int* dst_ptr = (int*)PyLong_AsVoidPtr(py_dst_ptr);

  size_t size = length * sizeof(int);
  CUDA_CHECK(cudaMemcpy(dst_ptr, src_ptr, size, cudaMemcpyDeviceToDevice));
  Py_RETURN_NONE;
}

// free CUDA device memory
static PyObject* py_cuda_free(PyObject* self, PyObject* args){
  PyObject* py_device_ptr;
  if(!PyArg_ParseTuple(args, "O", &py_device_ptr)){ return NULL; }
  int* device_ptr = (int*)PyLong_AsVoidPtr(py_device_ptr);
  if(device_ptr){ CUDA_CHECK(cudaFree(device_ptr)); }
  Py_RETURN_NONE;
}

// query available CUDA device memory
static PyObject* py_cuda_query_free_memory(PyObject* self, PyObject* args){
  size_t free_mem = 0, total_mem = 0;
  CUDA_CHECK(cudaMemGetInfo(&free_mem, &total_mem));
  return PyLong_FromSize_t(free_mem);
}

// method definitions
static PyMethodDef CuManagerMethods[] = {
  {"cuda_alloc", py_cuda_alloc, METH_VARARGS, "Allocate memory on the CUDA device"},
  {"memcpy_htod", py_memcpy_htod, METH_VARARGS, "Copy int vector from host to CUDA device"},
  {"memcpy_dtoh", py_memcpy_dtoh, METH_VARARGS, "Copy int vector from CUDA device to host"},
  {"memcpy_dtod", py_memcpy_dtod, METH_VARARGS, "Copy memory from one CUDA device location to another"},
  {"memcpy_htoh", py_memcpy_htoh, METH_VARARGS, "Copy int vector from host to host"},
  {"cuda_free", py_cuda_free, METH_VARARGS, "Free CUDA device memory"},
  {"cuda_query_free_memory", py_cuda_query_free_memory, METH_NOARGS, "Query available CUDA device memory"},
  {NULL, NULL, 0, NULL}
};

// module definition
static struct PyModuleDef cu_manager_module = {
  PyModuleDef_HEAD_INIT,
  "cu_manager",
  "CUDA memory management module",
  -1,
  CuManagerMethods
};

// module initialization
PyMODINIT_FUNC PyInit_cu_manager(void){
  return PyModule_Create(&cu_manager_module);
}
